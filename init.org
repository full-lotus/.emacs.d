:PROPERTIES:
:header-args: :comments both :noweb yes :mkdirp yes
:END:

* Purpose of this Emacs config
This config aims to maximize Clojure programmer productivity through:

1. /Making Emacs easy to learn on the go/
   Meaning lots of visual cues, not forcing user to Google every
   step for hotkeys and commands.

2. /Short hotkeys for most often used functionality/
   For example, 'C-o'/'M-o' for ~other-window/other-frame~. Mode <<<keyfreq>>>
   helps to find commands which need short hotkeys.

3. /Being minimalistic/
   I use Emacs as a tool, not a hobby. I customize things to get them out of
   the way of reaching deep concentration, not to enjoy shiny toys.

4. /<<<Literate programming>>> with <<<polymode>>>/
   To minimize context/abstraction switching overhead. Plus, figuring out
   *why* code was written is a huge waste of time and mental energy.

5. /Being dead obvious *why* some things were customized/
   In other words, the config itself is a Literate Program


* Emacs initialization
** Safe load: prevent errors from killing following initialization
#+begin_src elisp :tangle ./init.el
(defun safe-load (file)
  (condition-case load-err
      (load file)
    (error (message "Failed to load %s: %s" file load-err))))
#+end_src

#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/customization-api-tweaks.tngl.el")
#+end_src

** Separate custom.el from init.el
#+begin_src elisp :tangle ~/.emacs.d/elisp/customization-api-tweaks.tngl.el
;; separate custom-file because it's a mess, with everything in one place
(setq custom-file "~/.emacs.d/elisp/custom-set-variables.el")

;; we are loading at the top of init.el, to set custom variables nice and
;; separate, grouping relevant settings together
(safe-load custom-file)
#+end_src


* Package management
#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/package-management.tngl.el")
#+end_src

** Set URLs from which we search and download packages
#+begin_src elisp :tangle ~/.emacs.d/elisp/package-management.tngl.el
(setq package-archives
      '(("gnu" . "http://elpa.gnu.org/packages/")
	("non-gnu" . "https://elpa.nongnu.org/nongnu/")
	("melpa" . "http://melpa.org/packages/")))
#+end_src

** Init package.el, fetch available packages from URLs
#+begin_src elisp :tangle ~/.emacs.d/elisp/package-management.tngl.el
;; start package system (package.el, package dirs, available packages cache)
(package-initialize)

;; fetch the list of packages available, must run package-initialize first
(unless package-archive-contents
  (package-refresh-contents))
#+end_src

** Install and load all non-default packages
#+begin_src elisp :tangle ~/.emacs.d/elisp/package-management.tngl.el
;; install all non-default packages
(dolist (pkg package-selected-packages)
  (unless (package-installed-p pkg)
    (package-install pkg)))

;; require all non-default packages
(dolist (pkg package-selected-packages)
  (require pkg nil 'noerror))
#+end_src


* General global settings
#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/global-settings.tngl.el")
#+end_src

** Emacs startup/exit
#+begin_src elisp :tangle ~/.emacs.d/elisp/global-settings.tngl.el
(setq
 ;; Don't display load average
 display-time-default-load-average nil

 ;; Disable start-up screen
 inhibit-startup-screen t

 ;; Empty the initial *scratch* buffer
 initial-scratch-message ""

 ;; Confirm before exiting Emacs
 confirm-kill-emacs 'y-or-n-p
 )
#+end_src

** Elisp
#+begin_src elisp :tangle ~/.emacs.d/elisp/global-settings.tngl.el
;; the dir with elisp files to be loaded
(add-to-list 'load-path "~/.emacs.d/elisp/")

(setq
 ;; Silence warnings for redefinition
 ad-redefinition-action 'accept
 )

(defmacro comment (&rest body)
  "A simple way to comment out code in Emacs Lisp."
  nil)
#+end_src

** Use SSH through daemon launched on startup
#+begin_src elisp :tangle ~/.emacs.d/elisp/global-settings.tngl.el
(setenv "SSH_AUTH_SOCK" (concat (getenv "XDG_RUNTIME_DIR") "/ssh-agent.socket"))
#+end_src

** Sound
#+begin_src elisp :tangle ~/.emacs.d/elisp/global-settings.tngl.el
;; use screen flash instead of annoying error sound
(setq
 visible-bell t
 )
#+end_src

** Commands
*** History
#+begin_src elisp :tangle ~/.emacs.d/elisp/global-settings.tngl.el
;; save command history, e. g. for execute-extended-command
(savehist-mode 1)

;; keep a list of recently opened files
(recentf-mode 1)

;; use smex to show command history in counsel-M-x
(smex-initialize)
(setq smex-history-use-recent-first t)
#+end_src

*** Easier yes/no
#+begin_src elisp :tangle ~/.emacs.d/elisp/global-settings.tngl.el
;; Replace yes/no prompts with y/n
(fset 'yes-or-no-p 'y-or-n-p)
(setq use-short-answers t)
#+end_src

*** Easy (1 button) command repeat
#+begin_src elisp :tangle ~/.emacs.d/elisp/global-settings.tngl.el
;; make some multi-chord commands repeatable with 1 key press
;; for example - repeat C-x <LEFT> (previous-buffer) with just <LEFT>
(repeat-mode 1)
#+end_src

** Emacs temporary files
#+begin_src elisp :tangle ~/.emacs.d/elisp/global-settings.tngl.el
;; stop creating backup~ files
(setq make-backup-files nil)

;; stop creating #autosave# files
(setq auto-save-default nil)

;; no lockfiles
(setq create-lockfiles nil)

;; Don't clutter main Emacs folder with session. files
(defun emacs-session-filename (session-id)
  "Return the file name of the session file for SESSION-ID."
  (expand-file-name (concat "session." session-id)
                    "~/.emacs.d/sessions/"))
#+end_src


* Text
#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/text-settings.tngl.el")
#+end_src

** Navigation
*** Avy
#+begin_src elisp :tangle ~/.emacs.d/elisp/text-settings.tngl.el
(keymap-global-set "M-SPC" #'avy-goto-word-0)
#+end_src

*** Bookmarks (bm package)
#+begin_src elisp :tangle ~/.emacs.d/elisp/text-settings.tngl.el
(declare-function poly-org-mode? "org-mode.tangled")

(defun pm--org-reveal-inside-source-block ()
  "Temporarily switch back to org-mode, to be able to do proper unfolding"
  (interactive)
  (let ((pm? (and (poly-org-mode?) (not (eq 'org-mode major-mode))))
	(post-command-hook nil)
	(pm--move-overlays (lambda ()))
	(curr-point (point)))
    (when pm?
      ;; switch to org-mode without breaking polymode
      (goto-char (point-min))
      (polymode-post-command)
      (goto-char curr-point))

    ;; now, in org-mode, properly find parent heading and unfold it
    (org-up-element)
    (org-fold-show-subtree)

    ;; go back to original point and restore the major mode
    (goto-char curr-point)
    (when pm?
      (polymode-post-command))))

(use-package bm
  :ensure t
  :demand t

  :init
  ;; restore on load (even before you require bm)
  (setq bm-restore-repository-on-load t)

  :config
  ;; Allow cross-buffer 'next'
  (setq bm-cycle-all-buffers t)

  ;; where to store persistant files
  (setq bm-repository-file "~/.emacs.d/bm-repository")

  ;; save bookmarks
  (setq-default bm-buffer-persistence t)

  ;; Loading the repository from file when on start up.
  (add-hook 'after-init-hook 'bm-repository-load)

  ;; Saving bookmarks
  (add-hook 'kill-buffer-hook #'bm-buffer-save)

  ;; Saving the repository to file when on exit.
  ;; kill-buffer-hook is not called when Emacs is killed, so we
  ;; must save all bookmarks first.
  (add-hook 'kill-emacs-hook #'(lambda nil
                                 (bm-buffer-save-all)
                                 (bm-repository-save)))

  ;; The `after-save-hook' is not necessary to use to achieve persistence,
  ;; but it makes the bookmark data in repository more in sync with the file
  ;; state.
  (add-hook 'after-save-hook #'bm-buffer-save)

  ;; Restoring bookmarks
  (add-hook 'find-file-hooks   #'bm-buffer-restore)
  (add-hook 'after-revert-hook #'bm-buffer-restore)

  ;; The `after-revert-hook' is not necessary to use to achieve persistence,
  ;; but it makes the bookmark data in repository more in sync with the file
  ;; state. This hook might cause trouble when using packages
  ;; that automatically reverts the buffer (like vc after a check-in).
  ;; This can easily be avoided if the package provides a hook that is
  ;; called before the buffer is reverted (like `vc-before-checkin-hook').
  ;; Then new bookmarks can be saved before the buffer is reverted.
  ;; Make sure bookmarks is saved before check-in (and revert-buffer)
  (add-hook 'before-revert-hook #'bm-buffer-save)

  ;; org-mode expand the region containing a bookmark
  ;; (add-hook 'bm-after-goto-hook 'org-bookmark-jump-unhide)
  (add-hook 'bm-after-goto-hook 'pm--org-reveal-inside-source-block)

  ;; the markers on the right fringe instead of the left
  (setq bm-highlight-style 'bm-highlight-line-and-fringe)
  (setq bm-marker 'bm-marker-right)

  (bind-key* (kbd "<f2>") 'bm-next)
  (bind-key* (kbd "S-<f2>") 'bm-previous)
  (bind-key* (kbd "C-<f2>") 'bm-toggle))
#+end_src

*** Beacon mode - highlight cursor after jump
#+begin_src elisp :tangle ~/.emacs.d/elisp/text-settings.tngl.el
(beacon-mode 1)
#+end_src

** Display
#+begin_src elisp :tangle ~/.emacs.d/elisp/text-settings.tngl.el
;; blinking cursor is annoying
(blink-cursor-mode -1)

;; wrap lines at word boundaries, so that they always fit current window
(global-visual-line-mode 1)

;; display fill-column everywhere
(global-display-fill-column-indicator-mode 1)

;; Default to utf-8 encoding
(set-default-coding-systems 'utf-8)

(setq-default
 ;; to see when a line is longer than 80 symbols
 display-fill-column-indicator-column 80

 ;; set width for automatic line breaks
 fill-column 80

 ;; Add left and right margins
 left-margin-width 1 right-margin-width 1

 ;; don't display line numbers at their beginning
 ;; 'display-line-numbers-type nil

 ;; show column number in minibuffer
 column-number-mode t

 ;; Display trailing whitespaces
 show-trailing-whitespace nil

 ;; Set width for tabs
 tab-width 2

 ;; Stretch cursor to the glyph width
 x-stretch-cursor t
 )

(global-display-fill-column-indicator-mode t)
#+end_src

*** all-the-icons
#+begin_src elisp :tangle ~/.emacs.d/elisp/text-settings.tngl.el
(use-package all-the-icons
  :ensure t
  :config
  (unless (member "all-the-icons" (font-family-list))
    (all-the-icons-install-fonts t)))

(use-package all-the-icons-dired
  :ensure t
  :hook (dired-mode . all-the-icons-dired-mode))

(use-package all-the-icons-completion
  :ensure t
  :after marginalia
  :hook (marginalia-mode . all-the-icons-completion-mode))
#+end_src

** Editing
*** Whitespace
#+begin_src elisp :tangle ~/.emacs.d/elisp/text-settings.tngl.el
(setq

 ;; Stop using tabs to indent
 indent-tabs-mode nil

 ;; do not auto-end sentences
 sentence-end-double-space nil
 )

;; delete all trailing whitespace
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** Undo
#+begin_src elisp :tangle ~/.emacs.d/elisp/text-settings.tngl.el
;; make undo hotkey familiar
(global-set-key (kbd "C-z") 'undo)

;; use linear undo, store info between sessions
(global-undo-fu-session-mode 1)
#+end_src

*** Copy/paste
#+begin_src elisp :tangle ~/.emacs.d/elisp/text-settings.tngl.el
;; delete active region on yanking (paste)
(cua-mode 1)

(setq
 ;; save kill-ring between emacs session, up to 20 entries
 savehist-additional-variables '(kill-ring)
 kill-ring-max 20

 ;; saves OS clipboard content before kill, to prevent overwriting it
 save-interprogram-paste-before-kill t

 ;; sync system's and Emacs' clipboard
 select-enable-clipboard t

 ;; Yank at point rather than pointer
 mouse-yank-at-point t
 )
#+end_src

** Syncing with filesystem (reverting)
#+begin_src elisp :tangle ~/.emacs.d/elisp/text-settings.tngl.el
;; The auto-revert setting is enabled because tangle / detangle for literate
;; programming will change contents of files. If the file is open in a buffer,
;; I want it to automatically show the change without asking me every time.
(global-auto-revert-mode t)
#+end_src


* Frame/window/buffer configuration
#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/frame-window-buffer-settings.tngl.el")
#+end_src

** Display
*** Hide
#+begin_src elisp :tangle ~/.emacs.d/elisp/frame-window-buffer-settings.tngl.el
;; hide useless title bar, but allow resizing
(add-to-list 'default-frame-alist '(undecorated . t))
(add-to-list 'default-frame-alist '(drag-internal-border . 1))
(add-to-list 'default-frame-alist '(internal-border-width . 5))

;; I don't use toolbar, and rarely menu-bar
(tool-bar-mode 0)
(menu-bar-mode 0)

(setq
 ;; don't display time in frames
 display-time-mode 0

 ;; don't use sRGB colors
 ns-use-srgb-colorspace nil
 )
#+end_src

*** Splitting/resizing
#+begin_src elisp :tangle ~/.emacs.d/elisp/frame-window-buffer-settings.tngl.el
(setq
 ;; Disable vertical window splitting
 split-height-threshold nil

 ;; Allow horizontal splitting, if there's at least 1 column in the buffer
 split-width-threshold 1

 ;; Resize windows proportionally
 window-combination-resize t
 )
#+end_src

*** Creating buffers and choosing how to display them
#+begin_src elisp :tangle ~/.emacs.d/elisp/frame-window-buffer-settings.tngl.el
;; record changes in window configuration, to enable reverting them
(custom-set-variables
 '(winner-mode t))

(setq
 ;; Uniquify buffer names
 uniquify-buffer-name-style 'forward

 ;; Focus new help windows when opened
 help-window-select t

 ;; don't open new buffers when navigating dirs in dired
 dired-kill-when-opening-new-dired-buffer t

 display-buffer-alist
 '(;; without this, transient buffer breaks window layout
   ;; it happens because of conflicts with lower settings
   (".*transient.*"
    (display-buffer-in-side-window)
    (side . bottom)
    (inhibit-same-window . t)
    (window-parameters (no-other-window . t)))

   ;; treemacs is a file navigator, typically glued to the left screen side
   ("\\*Treemacs-.*?" (display-buffer-in-direction) (direction . left))

   ;; open in the same window
   ((or . ((major-mode . help-mode)
	   (major-mode . Custom-mode)
	   (major-mode . dired-mode)
	   (major-mode . clojure-mode)
	   (major-mode . cider-repl-mode)
	   "\\*cider-error.*\\*"
	   "\\*Org Src.*\\*"))
    (display-buffer-same-window)
    (display-buffer-reuse-window)
    (inhibit-same-window . nil)
    (inhibit-switch-frame . t))

   ;; open in another window - the default behavior
   (".*"
    (display-buffer-use-least-recent-window)
    (display-buffer-reuse-window)
    (inhibit-switch-frame . t))
   )
 )
#+end_src

** Scrolling
#+begin_src elisp :tangle ~/.emacs.d/elisp/frame-window-buffer-settings.tngl.el
(setq
 ;; Lighten vertical scroll
 auto-window-vscroll nil

 scroll-step 1
 scroll-conservatively 10000
 )
#+end_src

** Save/load frame configuration on exit/start
#+begin_src elisp :tangle ~/.emacs.d/elisp/frame-window-buffer-settings.tngl.el
(setq
 ;; always save window/frame/buffer config
 desktop-save t)

(desktop-save-mode t)
#+end_src

** Navigation
*** Buffer/window/frame switching, burying, treemacs
#+begin_src elisp :tangle ~/.emacs.d/elisp/frame-window-buffer-settings.tngl.el
(bind-key* (kbd "C-o") 'other-window)
(bind-key* (kbd "M-o") 'other-frame)
(global-set-key (kbd "C-S-b") 'treemacs)
(global-set-key (kbd "C-x w") 'bury-buffer)

(defun switch-buffer-in-current-window ()
  "Switch buffer in the current window, ignoring `display-buffer-alist`."
  (interactive)
  (let ((display-buffer-alist nil)) ;; Temporarily disable display-buffer-alist
    (call-interactively 'consult-buffer)))

(global-set-key (kbd "C-x b") #'switch-buffer-in-current-window)
(bind-key* (kbd "s-b") 'switch-buffer-in-current-window)
(bind-key* (kbd "s-k") 'kill-buffer)
#+end_src

*** Tabs
Couldn't find desirable tab functionality which would allow me to tab through
different parts on 1 file, having a set of tabs for each window.

- tab-line-mode/centaur-tabs aren't suitable because of indirect buffer bugs
  and because they don't open the same buffer in different tabs of the same
  window
- tab-bar-mode works, but doesn't have window-specific tabs

#+begin_src elisp :tangle ~/.emacs.d/elisp/frame-window-buffer-settings.tngl.el
(tab-bar-mode t)

(global-set-key (kbd "C-x C-<left>") 'tab-bar-switch-to-prev-tab)
(global-set-key (kbd "C-x C-<right>") 'tab-bar-switch-to-next-tab)
#+end_src

** Minibuffer
#+begin_src elisp :tangle ~/.emacs.d/elisp/frame-window-buffer-settings.tngl.el
(setq enable-recursive-minibuffers t)
#+end_src


* Command/code completion
#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/completions.tngl.el")
#+end_src

** which-key mode
Shows completion options, after you start pressing hotkeys

#+begin_src elisp :tangle ~/.emacs.d/elisp/completions.tngl.el
(which-key-mode 1)
#+end_src

** keyfreq mode
Records how much times a command was used. Useful for optimizing hotkeys

#+begin_src elisp :tangle ~/.emacs.d/elisp/completions.tngl.el
(keyfreq-mode 1)
(keyfreq-autosave-mode 1)

(setq
 keyfreq-excluded-commands
 '(self-insert-command
   forward-char
   backward-char
   previous-line
   next-line))
#+end_src

** Code completion
#+begin_src elisp :tangle ~/.emacs.d/elisp/completions.tngl.el
;; Always show completions
(setq completion-auto-help 'always)

;; Auto-select *Completions* buffer
(setq completion-auto-select 'second-tab)

;; Make <TAB> invoke completions list, when code is already idented properly
(setq tab-always-indent 'complete)
#+end_src

** Snippets (yasnippet)
#+begin_src elisp :tangle ~/.emacs.d/elisp/completions.tngl.el
(setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
(yas-global-mode 1)
#+end_src

** Vertico + Consult + Ordqerless + Embark + Marginalia + Corfu + Cape
Shamelessly copied from [[https://github.com/jamescherti/minimal-emacs.d][minimal-emacs setup]].

#+begin_src elisp :tangle ~/.emacs.d/elisp/completions.tngl.el
;; Corfu enhances in-buffer completion by displaying a compact popup with
;; current candidates, positioned either below or above the point. Candidates
;; can be selected by navigating up or down.
(use-package corfu
  :ensure t
  :commands (corfu-mode global-corfu-mode)

  :hook ((prog-mode . corfu-mode)
         (shell-mode . corfu-mode)
         (eshell-mode . corfu-mode))

  :custom
  ;; Hide commands in M-x which do not apply to the current mode.
  (read-extended-command-predicate #'command-completion-default-include-p)
  ;; Disable Ispell completion function. As an alternative try `cape-dict'.
  (text-mode-ispell-word-completion nil)
  (tab-always-indent 'complete)

  ;; Enable Corfu
  :config
  (global-corfu-mode))

;; Cape, or Completion At Point Extensions, extends the capabilities of
;; in-buffer completion. It integrates with Corfu or the default completion UI,
;; by providing additional backends through completion-at-point-functions.
(use-package cape
  :ensure t
  :commands (cape-dabbrev cape-file cape-elisp-block)
  :bind ("C-c p" . cape-prefix-map)
  :init
  ;; Add to the global default value of `completion-at-point-functions' which is
  ;; used by `completion-at-point'.
  (add-hook 'completion-at-point-functions #'cape-dabbrev)
  (add-hook 'completion-at-point-functions #'cape-file)
  (add-hook 'completion-at-point-functions #'cape-elisp-block))

;; Vertico provides a vertical completion interface, making it easier to
;; navigate and select from completion candidates (e.g., when `M-x` is pressed).
(use-package vertico
  ;; (Note: It is recommended to also enable the savehist package.)
  :ensure t
  :config
  (vertico-mode))

;; Vertico leverages Orderless' flexible matching capabilities, allowing users
;; to input multiple patterns separated by spaces, which Orderless then
;; matches in any order against the candidates.
(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion))
				   (buffer (styles orderless))
				   (command (styles orderless))
				   (symbol (styles orderless))
				   (function (styles orderless))
				   (variable (styles orderless))
				   (consult-location (styles orderless))
				   (consult-multi (styles orderless))))
  )

;; Marginalia allows Embark to offer you preconfigured actions in more contexts.
;; In addition to that, Marginalia also enhances Vertico by adding rich
;; annotations to the completion candidates displayed in Vertico's interface.
(use-package marginalia
  :ensure t
  :commands (marginalia-mode marginalia-cycle)
  :hook (after-init . marginalia-mode))

;; Embark integrates with Consult and Vertico to provide context-sensitive
;; actions and quick access to commands based on the current selection, further
;; improving user efficiency and workflow within Emacs. Together, they create a
;; cohesive and powerful environment for managing completions and interactions.
(use-package embark
  ;; Embark is an Emacs package that acts like a context menu, allowing
  ;; users to perform context-sensitive actions on selected items
  ;; directly from the completion interface.
  :ensure t
  :commands (embark-act
             embark-dwim
             embark-export
             embark-collect
             embark-bindings
             embark-prefix-help-command)
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-c C-o" . embark-export)  ;; like ivy-occur
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init
  (setq prefix-help-command #'embark-prefix-help-command)

  :config
  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
  (setcdr (assq 'consult-location embark-exporters-alist)
	  'embark-consult-export-location-grep))

(use-package embark-consult
  :ensure t
  :hook
  (embark-collect-mode . consult-preview-point-mode))

;; Consult offers a suite of commands for efficient searching, previewing, and
;; interacting with buffers, file contents, and more, improving various tasks.
(use-package consult
  :ensure t
  :bind (;; C-c bindings in `mode-specific-map'
         ("C-c M-x" . consult-mode-command)
         ("C-c h" . consult-history)
         ("C-c k" . consult-kmacro)
         ("C-c m" . consult-man)
         ("C-c i" . consult-info)
         ([remap Info-search] . consult-info)
         ;; C-x bindings in `ctl-x-map'
         ("C-x M-:" . consult-complex-command)
         ("C-x b" . consult-buffer)
         ("C-x 4 b" . consult-buffer-other-window)
         ("C-x 5 b" . consult-buffer-other-frame)
         ("C-x t b" . consult-buffer-other-tab)
         ("C-x r b" . consult-bookmark)
         ("C-x p b" . consult-project-buffer)
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)
         ;; M-g bindings in `goto-map'
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-g o" . consult-outline)
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings in `search-map'
         ("M-s d" . consult-find)
         ("M-s c" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
	 ("C-s" . consult-line)
	 ("C-f" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)
         ("M-s e" . consult-isearch-history)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)
         ("M-r" . consult-history))

  ;; Enable automatic preview at point in the *Completions* buffer.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  :init
  ;; Optionally configure the register formatting. This improves the register
  (setq register-preview-delay 0.5
        register-preview-function #'consult-register-format)

  ;; Optionally tweak the register preview window.
  (advice-add #'register-preview :override #'consult-register-window)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Aggressive asynchronous that yield instantaneous results. (suitable for
  ;; high-performance systems.) Note: Minad, the author of Consult, does not
  ;; recommend aggressive values.
  ;; Read: https://github.com/minad/consult/discussions/951
  ;;
  ;; However, the author of minimal-emacs.d uses these parameters to achieve
  ;; immediate feedback from Consult.
  ;; (setq consult-async-input-debounce 0.02
  ;;       consult-async-input-throttle 0.05
  ;;       consult-async-refresh-delay 0.02)

  :config
  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   ;; :preview-key "M-."
   :preview-key '(:debounce 0.4 any))
  (setq consult-narrow-key "<"))
#+end_src


* Improved text replace
Make search-and-replace across project work as convenient as in VS Code.

#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/improved-text-replace.tngl.el")
#+end_src

** Wgrep
#+begin_src elisp :tangle ~/.emacs.d/elisp/improved-text-replace.tngl.el
;; wgrep allows to convert grep buffers to editable, to get VS Code-like
;; search and replace experience
(use-package wgrep
  :ensure t
  :custom
  (wgrep-auto-save-buffer t)
  (wgrep-change-readonly-file t))
#+end_src

** Replace+.el
Allows to invoke replace fn with a search regex in the list of defaults.
The defaults are cycled in minibuffer with up/down arrows.

#+begin_src elisp :tangle ~/.emacs.d/elisp/improved-text-replace.tngl.el
(safe-load "~/.emacs.d/elisp/replace+.el")

;; this prevents replace+ being limited to an active region
(setq search/replace-region-as-default-flag t)

(defun get-initial-input-for-replace ()
  nil)
(setq search/replace-default-fn 'get-initial-input-for-replace)

(defun query-replace-regexp-with-initial-input (input)
  (eval
   '(let ((original-fn (symbol-function 'initial-input-for-replace)))
      (fset 'get-initial-input-for-replace (lambda () (regexp-quote input)))
      (unwind-protect
          (call-interactively 'query-replace-regexp)
        (fset 'get-initial-input-for-replace original-fn)))
   t))
#+end_src


* Programming
#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/programming-settings.tngl.el")
#+end_src

** Syntax checking
#+begin_src elisp :tangle ~/.emacs.d/elisp/programming-settings.tngl.el
;; check syntax globally
(global-flycheck-mode)
#+end_src

** Parenthesis config
*** Puni-mode
#+begin_src elisp :tangle ~/.emacs.d/elisp/programming-settings.tngl.el
;; toggle puni-mode manually
(global-set-key (kbd "M-P") 'puni-mode)

(puni-global-mode 1)

;; puni-mode doesn't have auto-pairing
(electric-pair-mode 1)

;; use sexp editing hotkeys from VS Code Calva, to which I am used to
(define-key puni-mode-map (kbd "C-<right>") 'puni-forward-sexp)
(define-key puni-mode-map (kbd "C-<left>") 'puni-backward-sexp)
(define-key puni-mode-map (kbd "C-M-.") 'puni-slurp-forward)
(define-key puni-mode-map (kbd "C-M-,") 'puni-barf-forward)
(define-key puni-mode-map (kbd "C-M->") 'puni-barf-backward)
(define-key puni-mode-map (kbd "C-M-<") 'puni-slurp-backward)

;; puni conflicts with read-only text sometimes
;; e. g. deletion of consult-buffer narrowing prefixes
(add-hook 'minibuffer-setup-hook (lambda () (puni-mode -1)))
#+end_src

*** Display
#+begin_src elisp :tangle ~/.emacs.d/elisp/programming-settings.tngl.el
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)

;; always highlight matching paren
(show-paren-mode 1)
#+end_src

** Clojure
*** CIDER
#+begin_src elisp :tangle ~/.emacs.d/elisp/programming-settings.tngl.el
(setq
 nrepl-hide-special-buffers t
 cider-repl-clear-help-banner t
 cider-font-lock-dynamically '(macro core function var)
 cider-popup-stacktraces nil
 cider-repl-popup-stacktraces t
 cider-repl-use-pretty-printing t
 cider-repl-pop-to-buffer-on-connect nil
 cider-repl-display-help-banner nil
 cider-use-overlays nil
 ;; when using 2 poly-org buffers on the same file, tooltips cause point in
 ;; non-selected buffer to jump between source blocks
 cider-use-tooltips nil
 )

;; enforce simple formatting style
;; I had issues with clojure-mode bugging out and not detecting macros
(setq
 clojure-indent-style 'always-indent
 clojure-indent-keyword-style 'always-indent
 clojure-enable-indent-specs nil)

;; Allow cider-repl to be cleared with shortcut
(add-hook 'cider-repl-mode-hook
      '(lambda () (define-key cider-repl-mode-map (kbd "C-c M-b")
                              'cider-repl-clear-buffer)))

;; use CIDER in every Clojure buffer
(add-hook 'clojure-mode-hook #'cider-mode)
(add-hook 'clojurescript-mode-hook #'cider-mode)

(add-hook 'cider-mode-hook #'imenu-add-menubar-index)

;; I write tests in the same ns as source code, source and tests must be close
(setq cider-test-infer-test-ns (lambda (ns) ns))

;; use the same hotkeys as in VS Code Calva
(define-key cider-repl-mode-map [C-return] nil)
(define-key cider-mode-map [C-return] 'cider-eval-sexp-at-point)
(define-key cider-mode-map (kbd "M-<RET>") 'cider-eval-defun-at-point)
(define-key cider-repl-mode-map [C-return] 'cider-eval-sexp-at-point)
(define-key cider-repl-mode-map (kbd "M-<RET>") 'cider-eval-defun-at-point)
;; prevent conflict with CUA-mode
(define-key cua-global-keymap [C-return] nil)
#+end_src

**** Routing expressions to CLJ/CLJS REPL for evaluation
#+begin_src elisp :tangle ~/.emacs.d/elisp/programming-settings.tngl.el
(defun eval-last-sexp-in-specific-repl (repl-type)
  "Evaluate the last expression only in the 'clj or 'cljs REPL."
  (interactive)
  (let ((form (cider-last-sexp))
        (cljs-conn (cider-current-connection repl-type)))
    (when (and form cljs-conn)
      (nrepl-request:eval form
                          (cider-interactive-eval-handler)
                          cljs-conn))))

(defun eval-last-sexp-in-clj ()
  "Evaluate the last expression only in the Clojure (not CLJS) REPL."
  (interactive)
  (eval-last-sexp-in-specific-repl 'clj))

(defun eval-last-sexp-in-cljs ()
  "Evaluate the last expression only in the ClojureScript REPL."
  (interactive)
  (eval-last-sexp-in-specific-repl 'cljs))

(define-key cider-mode-map (kbd "C-M-<return>") 'eval-last-sexp-in-clj)
(define-key cider-mode-map (kbd "C-S-<return>") 'eval-last-sexp-in-cljs)
#+end_src

** CSS
#+begin_src elisp :tangle ~/.emacs.d/elisp/programming-settings.tngl.el
(setq css-indent-offset 2)
#+end_src


* Org-mode (literate programming)
#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/org-mode.tngl.el")
#+end_src

** Time-tracking
#+begin_src elisp :tangle ~/.emacs.d/elisp/org-mode.tngl.el
;; closing Emacs/buffers must not stop work clock
(setq org-clock-persist 'history)
(org-clock-persistence-insinuate)
#+end_src

** Navigation
*** Single-letter hotkeys
#+begin_src elisp :tangle ~/.emacs.d/elisp/org-mode.tngl.el
(setq org-use-speed-commands t)
#+end_src

** Initialization
#+begin_src elisp :tangle ~/.emacs.d/elisp/org-mode.tngl.el
(eval-after-load 'org
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((clojure . t)
     (clojurescript . t)
     (emacs-lisp . t)
     (shell . t))))

(setq
 org-startup-folded nil

 ;; not sure how/why this variable was set, decided not to mess with it
 org-modules '(ol-docview ol-doi ol-info org-tempo))
#+end_src

** Display
*** General
#+begin_src elisp :tangle ~/.emacs.d/elisp/org-mode.tngl.el
;; background colors are changed to be consistent with src-blocks in org-mode
(setq
 org-src-fontify-natively t
 org-src-block-faces '(("elisp" (:background "lavender"))
                       ("emacs-lisp" (:background "lavender"))
                       ("clojure" (:background "lavender"))
                       ("clojurescript" (:background "lavender"))
                       ("clojurec" (:background "lavender"))))

(setq
 ;; open src blocks in the same window as parent .org file
 org-src-window-setup 'current-window

 org-hide-leading-stars t

 ;; do not display inline images when doing org-cycle
 org-cycle-inline-images-display nil

 org-link-frame-setup '(;; open file links in another frame
			(file . find-file-other-frame)))
#+end_src

*** Heading subtree fold state cycling
#+begin_src elisp :tangle ~/.emacs.d/elisp/org-mode.tngl.el
(defun org-cycle-current-subtree (orig-fun &rest args)
  "Cycle fold state of current heading similar to org-shifttab, if org-cycle
is called with without C-u prefix.

Cycles through three states:
1. folded (content hidden)
2. children visible (direct subheadings shown)
3. subtree expanded (everything visible)"
  (interactive)
  (cond
   ((or (not (org-at-heading-p))
				(eq (prefix-numeric-value current-prefix-arg) 4))
    (apply orig-fun args))

   (t
    (save-excursion
      (let ((beg (progn (org-back-to-heading t) (point)))
            ;; end manipulation needed to not screw up separator newlines
            (end (progn (org-end-of-subtree t t nil) (end-of-line) (point))))
			  (save-restriction
		      (narrow-to-region beg end)
		      (org-cycle-internal-global)))))))

(advice-add 'org-shifttab :around 'org-cycle-current-subtree)
;; (advice-remove 'org-shifttab 'org-cycle-current-subtree)


;; Remove the function which causes text to pop around when pressing tab.
;; This is annoying and confusing.
(remove-hook 'org-cycle-hook
             'org-optimize-window-after-visibility-change)
#+end_src

** Linking
*** General
#+begin_src elisp :tangle ~/.emacs.d/elisp/org-mode.tngl.el
;; links that use header text:
;; 1. break easily
;; 2. can't link to a header which is a link
;; therefore, use org ids for linking
(setq org-id-link-to-org-use-id t)
(define-key org-mode-map (kbd "C-c l") 'org-store-link)
(define-key org-mode-map (kbd "<f5>") 'org-id-get-create)
(define-key org-mode-map (kbd "<f9>") 'org-id-copy)
#+end_src

*** Custom :src source block header
<<<:src>>> is a custom header that I add manually to noref code blocks

#+begin_src elisp :tangle ~/.emacs.d/elisp/org-mode.tngl.el
(defun org-babel-open-tangle-file ()
  "Opens the file specified by :tangle org :src header argument"
  (interactive)
  (let* ((info (org-babel-get-src-block-info))
         (tangle (cdr (assoc :tangle (nth 2 info))))
	 (src (cdr (assoc :src (nth 2 info)))))
    (if (not (equal tangle "no"))
	(find-file tangle)
      (when src (find-file src)))))
(define-key org-mode-map (kbd "C-c o") 'org-babel-open-tangle-file)
#+end_src

** Editing
#+begin_src elisp :tangle ~/.emacs.d/elisp/org-mode.tngl.el
(setq
 org-support-shift-select 'always
 org-hide-emphasis-markers nil
 org-edit-src-content-indentation 0
 org-src-tab-acts-natively t

 ;; For languages with significant whitespace like Python:
 org-src-preserve-indentation t
 )

;; Trying to fix weird org syntax problems. This just lets Org ignore < and >
;; characters as if they were regular words. This is necessary because in
;; Clojure I want to make functions with -> in the name and Org was always
;; insisting on pairing <>. This caused any other paren matching to stop
;; working. It sucked.
(defun my-angle-bracket-fix ()
  (modify-syntax-entry ?< "w")
  (modify-syntax-entry ?> "w"))
(add-hook 'org-mode-hook 'my-angle-bracket-fix)
(remove-hook 'org-mode-hook 'my-angle-bracket-fix)
#+end_src

** Code execution
*** Clojure namespace determination
I use file from custom :src or :tangle header to determine proper ns for eval

#+begin_src elisp :tangle ~/.emacs.d/elisp/org-mode.tngl.el
(defun get-buffer-major-mode (buffer-name)
  (with-current-buffer buffer-name
    major-mode))

(defun poly-org-mode? ()
  (and (bound-and-true-p polymode-mode)
       (eq (get-buffer-major-mode (pm-base-buffer)) 'org-mode)))

(defun org-get-ns-file ()
  (let* ((block-info (org-babel-get-src-block-info 'light))
         (header-args (nth 2 block-info))
	 (tangle-value (alist-get :tangle header-args))
	 (tangle-file (and (not (string= tangle-value "no"))
			   tangle-value))
         (ns-file (or tangle-file
			  (alist-get :src header-args))))
    (if (or (eq nil ns-file) (not (file-exists-p ns-file)))
	nil
      ns-file)))

(defun org-clojure-block-get-ns (orig-fun &rest args)
  "Wrap org-cider-current-ns, to enable REPL execution straight from org-mode.
Searches for ns in :tangle or :src file, otherwise calls clojure-find-ns."
  (if-let ((_ (poly-org-mode?))
	   (ns-file (org-get-ns-file)))
      (with-temp-buffer
	    (insert-file-contents ns-file)
	    (goto-char (point-min))
	    (clojurec-mode)
	    (clojure-find-ns))
    (apply orig-fun args)))

(advice-add 'cider-current-ns :around 'org-clojure-block-get-ns)
;; (advice-remove 'cider-current-ns 'org-clojure-block-get-ns)
#+end_src

** Tangling
#+begin_src elisp :tangle ~/.emacs.d/elisp/org-mode.tngl.el
;; override broken fn, which deletes comments from clojure code
(safe-load "~/.emacs.d/elisp/ob-clojure-fix.el")
(advice-add 'org-babel-expand-body:clojure
	    :override #'org-babel-expand-body:clojure_fixed)
#+end_src


* Many major mods in one buffer - polymode (poly-org)
#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/polymode.tngl.el")
#+end_src

** Flycheck fix
Prevents flycheck from confusing buffers and breaking down. See this [[https://github.com/polymode/poly-org/issues3/][issue]]

#+begin_src elisp :tangle ~/.emacs.d/elisp/polymode.tngl.el
(defun flycheck-buffer-not-indirect-p (&rest _)
  "Ensure that the current buffer is not indirect."
  (null (buffer-base-buffer)))

(advice-add 'flycheck-may-check-automatically
            :before-while #'flycheck-buffer-not-indirect-p)
#+end_src

** Background color fix
#+begin_src elisp :tangle ~/.emacs.d/elisp/polymode.tngl.el
;; polymode ignores background face config for both inner modes and org mode
(add-hook
 'polymode-init-inner-hook
 (lambda ()
   (oset pm/chunkmode adjust-face
	 '(:background "lavender"
           :extend t))))
#+end_src

** Source blocks display fix
#+begin_src elisp :tangle ~/.emacs.d/elisp/polymode.tngl.el
;; these supposed to prevent breaking display of source blocks
(setq
 org-adapt-indentation nil
 org-startup-indented nil)
#+end_src

** Fix for tangling inside source blocks, when noweb-refs are present
I spent 3 days trying to fix this [[https://github.com/polymode/poly-org/issues/53][issue]]. This hack avoids dealing with all the
difficult noweb expansion and its conflict with polymode.

#+begin_src elisp :tangle ~/.emacs.d/elisp/polymode.tngl.el
(defun pm--tangle-inside-source-block ()
  "Do tangling in a temporary copy of .org buffer, because
org-babel-expand-noweb-references explodes polymode. Don't save anything."
  (interactive)
  (cond
   ((not (poly-org-mode?)) nil)

   (t (let* ((inhibit-redisplay t)
             (inhibit-modification-hooks t)
	     (post-command-hook nil)
	     ;; we don't need overlay switching for this command
	     (pm--move-overlays (lambda ()))
	     (base-buf (pm-base-buffer))
	     (temp-file-name (concat (buffer-local-value
				      'buffer-file-name base-buf) "-temp")))
	(with-temp-buffer
	  (setq
	   buffer-file-name temp-file-name
           default-directory (buffer-local-value 'default-directory base-buf))
	  (insert-buffer-substring base-buf)
	  (org-mode)
	  (cl-letf (((symbol-function 'save-buffer) #'ignore)
		  ((symbol-function 'basic-save-buffer) #'ignore)
		  ((symbol-function 'save-some-buffers) #'ignore))
	    (org-babel-tangle))
	  (set-buffer-modified-p nil))))))

(define-key polymode-mode-map (kbd "C-c C-v C-t")
	    'pm--tangle-inside-source-block)
#+end_src

** Region random resize fix
#+begin_src elisp :tangle ~/.emacs.d/elisp/polymode.tngl.el
;; eldoc causes issues in my setup, sometimes marked region resizes randomly
;; tried eldoc-box to replace it, but it didn't work most of the time
;; all this is true for poly-org + clojurec + cider

(global-eldoc-mode -1)

(add-hook 'emacs-lisp-mode-hook (lambda () (eldoc-mode)))
#+end_src


* File management
#+begin_src elisp :tangle ./init.el
(safe-load "~/.emacs.d/elisp/file-management.tngl.el")
#+end_src

** Permissions
#+begin_src elisp :tangle ~/.emacs.d/elisp/file-management.tngl.el
;; trying these setting to be able to edit files as root
(require 'tramp)
(setq tramp-default-method "sudoedit")

#+end_src

** Extensions
#+begin_src elisp :tangle ~/.emacs.d/elisp/file-management.tngl.el
;; mode that enables choosing program-to-open-with based on file extensions
(openwith-mode t)

(custom-set-variables
  ;; associate file extensions (regex) to program-to-open-with
  '(openwith-associations
    '(("\\.\\(doc\\|docx\\)\\'" "libreoffice.writer"
        (file))
      )))
#+end_src
